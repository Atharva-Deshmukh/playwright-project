import { test, expect } from '@playwright/test';

test('Verify alert', async ({ page }) => {

  /* Handle alert as below */
  page.on('dialog', async (dialog) => {
    expect(await dialog.type()).toBe('alert');                 /* Type of dialog */
    expect(await dialog.message()).toBe('I am an alert box!'); /* Message of dialog */
    await dialog.accept();                                     /* Accept the alert */
  });

  const url: string = 'https://testautomationpractice.blogspot.com/';
  const expectedPageTitle: string = 'Automation Testing Practice';
  const alertButton = await page.locator('#alertBtn');

  await page.goto(url);

  await expect(page).toHaveTitle(expectedPageTitle);
  await expect(alertButton).toBeVisible().then(async () => {
      await alertButton.click();
      await page.waitForTimeout(5000); // Hard Wait for 5 seconds to observe the alert
  });

});

test('Verify Confirmation with OK', async ({ page }) => {

  page.on('dialog', async (dialog) => {
    expect(await dialog.type()).toBe('confirm');             /* Type of dialog */
    expect(await dialog.message()).toBe('Press a button!');  /* Message of dialog */
    await dialog.accept();   /* Closes confirmation with OK */
    // await dialog.dismiss();   /* Closes confirmation with Cancel */
  });

  const url: string = 'https://testautomationpractice.blogspot.com/';
  const expectedPageTitle: string = 'Automation Testing Practice';
  const confirmButton = await page.locator('#confirmBtn');

  await page.goto(url);

  await expect(page).toHaveTitle(expectedPageTitle);
  await expect(confirmButton).toBeVisible().then(async () => {
      await confirmButton.click();
  });

});

test('Verify Prompt dialogue with OK and some message', async ({ page }) => {

  page.on('dialog', async (dialog) => {
    expect(await dialog.type()).toBe('prompt');             /* Type of dialog */
    expect(await dialog.message()).toBe('Please enter your name:');  /* Message of dialog */
    expect(await dialog.defaultValue()).toBe('Harry Potter'); /* Default value in the prompt */

    await dialog.accept('INPUT MESSAGE');   /* Closing prompt with some input message */
    // await dialog.dismiss();   /* Closes prompt with Cancel */
  });

  const url: string = 'https://testautomationpractice.blogspot.com/';
  const expectedPageTitle: string = 'Automation Testing Practice';
  const promptButton = await page.locator('#promptBtn');

  await page.goto(url);

  await expect(page).toHaveTitle(expectedPageTitle);
  await expect(promptButton).toBeVisible().then(async () => {
      await promptButton.click();
      expect(await page.locator('p#demo')).toHaveText('Hello INPUT MESSAGE! How are you today?');
  });
});

test('Handling Basic authentication popup Way-1', async ({ page }) => {

  // We will add username and pwd directly in URL before domain name
  const url: string = 'https://admin:admin@the-internet.herokuapp.com/basic_auth';
  //                          ----------

  const authSuccessLocator = await page.locator('h3:has-text("Basic Auth")');

  await page.goto(url);
  await expect(authSuccessLocator).toBeVisible();
});

test('Handling Basic authentication popup Way-2', async ({ page }) => {

  /* In postman console we can see
    GET https://the-internet.herokuapp.com/basic_auth
    200
    253 ms
    Network
    Request Headers
    Authorization: Basic YWRtaW46YWRtaW4=
                  -----------------------
                  This is the token that is generated by encoding the username and password
                  It is generated by a common JS method btoa()

    User-Agent: PostmanRuntime/7.45.0 */

  const url: string = 'https://the-internet.herokuapp.com/basic_auth';
  const authSuccessLocator = await page.locator('h3:has-text("Basic Auth")');

  const username: string = 'admin';
  const password: string = 'admin';
  const authToken: string = 'Basic ' + btoa(`${username}:${password}`);

  await page.setExtraHTTPHeaders({
    'Authorization': authToken
  });

  await page.goto(url);
  await expect(authSuccessLocator).toBeVisible();
});

test('Configured Basic Authentication Way-3', async ({ page }) => {

  const url: string = 'https://the-internet.herokuapp.com/basic_auth';

  /* use: {

    httpCredentials: {
      username: 'admin',
      password: 'admin',
    }
  }, */

  const authSuccessLocator = await page.locator('h3:has-text("Basic Auth")');

  await page.goto(url);
  await expect(authSuccessLocator).toBeVisible();
});

/* Scenario:
   - Popup will appear randomly after max. 6 seconds
   - until its closed, no further action is possible

   We will use await page.addLocatorHandler()
   This method lets you set up a special function, called a handler, 
   that activates when it detects that overlay is visible. The handler's job is to remove the overlay, 
   allowing your test to continue as if the overlay wasn't there.

   Playwright checks for the overlay every time before executing or retrying an action that requires an 
   actionability check, or before performing an auto-waiting assertion check. When overlay is visible, 
   Playwright calls the handler first, and then proceeds with the action/assertion. Note that the 
   handler is only called when you perform an action/assertion - if the overlay becomes visible 
   but you don't perform any actions, the handler will not be triggered.

   We also need to specify when to stop waiting for the handler
   -------------------------------------------------------------
   An example with a custom callback on every actionability check. It uses a <body> 
   locator that is always visible, so the handler is called before every actionability check. 
   It is important to specify noWaitAfter, because the handler does not hide the <body> element.

  // Setup the handler.
  await page.addLocatorHandler(page.locator('body'), async () => {
    await page.evaluate(() => window.removeObstructionsForTestIfNeeded());
  }, { noWaitAfter: true });

  By default, after calling the handler Playwright will wait until the overlay becomes hidden, 
  and only then Playwright will continue with the action/assertion that triggered the handler. 
  This option allows to opt-out of this behavior, so that overlay can stay visible after the handler has run.

  // Write the test as usual.
  await page.goto('https://example.com');
  await page.getByRole('button', { name: 'Start here' }).click();

  You can also automatically remove the handler after a number of invocations by setting times:
    await page.addLocatorHandler(page.getByLabel('Close'), async locator => {
      await locator.click();
    }, { times: 1 });
*/
test.only('Handling Randomly appearing MODALS', async ({ page }) => {

  const url: string = 'https://commitquality.com/practice-random-popup';
  const accordianLocator = await page.getByText('Accordion 1');
  const modalLocator = await page.locator('.overlay-content p:has-text("Random Popup")');
  const closeModalButtonLocator = await page.locator('.overlay-content button:has-text("Close")');

  /* Setup the handler to close the modal */
  await page.addLocatorHandler(modalLocator, async () => {
    await closeModalButtonLocator.click();
  }, {times: 1});

  await page.goto(url);
  await expect(accordianLocator).toBeVisible();
  await new Promise(resolve => setTimeout(resolve, 6000)); // Wait for the modal to appear
  await accordianLocator.click();
});